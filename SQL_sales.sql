-- Наша задача — создать базу данных и таблицу для хранения информации о продажах.
-- Это нужно, чтобы гарантировать, что наши данные хранятся в структурированном виде.

CREATE DATABASE IF NOT EXISTS my_database;
USE my_database;

CREATE TABLE IF NOT EXISTS my_table (
    ID_Строки INT PRIMARY KEY, -- Уникальный идентификатор строки  
    ID_Заказа VARCHAR(50) NOT NULL, -- Идентификатор заказа  
    Дата_Заказа DATE NOT NULL, -- Дата оформления заказа  
    Дата_Отгрузки DATE NOT NULL, -- Дата отгрузки заказа  
    Способ_Доставки VARCHAR(50) NOT NULL, -- Способ доставки  
    ID_Клиента VARCHAR(50) NOT NULL, -- Уникальный идентификатор клиента  
    Имя_Клиента VARCHAR(100) NOT NULL, -- Имя клиента  
    Сегмент VARCHAR(50) NOT NULL, -- Сегмент клиента  
    Страна VARCHAR(50) NOT NULL, -- Страна доставки  
    Город VARCHAR(50) NOT NULL, -- Город доставки  
    Штат VARCHAR(50) NOT NULL, -- Штат или область  
    Почтовый_Код VARCHAR(20), -- Почтовый индекс  
    Регион VARCHAR(50) NOT NULL, -- Регион доставки  
    ID_Товара VARCHAR(50) NOT NULL, -- Уникальный идентификатор товара  
    Категория VARCHAR(50) NOT NULL, -- Категория товара  
    Подкатегория VARCHAR(50) NOT NULL, -- Подкатегория товара  
    Название_Товара TEXT NOT NULL, -- Название товара  
    Сумма_Продажи DECIMAL(12,2) NOT NULL -- Сумма продажи  
);

# Результат — создана база данных с таблицей для хранения данных о продажах.

-- Наша задача — проверить структуру базы данных.
SELECT DATABASE();
DESCRIBE my_table;
# Результат — убеждаемся, что структура таблицы правильная.

-- Наша задача — загрузить данные из CSV-файла.
SET GLOBAL local_infile = 1;

LOAD DATA INFILE 'A:/Program A/MySQL/MySQL Server 8.0/Uploads/cleaned_data.csv'
INTO TABLE my_table
FIELDS TERMINATED BY ','
ENCLOSED BY '"'
LINES TERMINATED BY '\n'
IGNORE 1 ROWS;

# Результат — данные загружены в таблицу my_table.

-- Наша задача — проверить корректность загруженных данных.
SELECT * FROM my_table LIMIT 10;
# Результат — видим первые 10 строк и проверяем правильность данных.

-- Наша задача — выявить самые дорогие товары, чтобы исключить ошибки в ценах.
SELECT Название_Товара, Сумма_Продажи 
FROM my_table 
ORDER BY Сумма_Продажи DESC 
LIMIT 10;
# Результат — проверяем 10 самых дорогих товаров на предмет аномальных значений.

-- Наша задача — вычислить общую выручку по месяцам.
SELECT 
    DATE_FORMAT(Дата_Заказа, '%Y-%m') AS Месяц, 
    SUM(Сумма_Продажи) AS Выручка_За_Месяц
FROM my_table
GROUP BY Месяц
ORDER BY Месяц;
# Результат — видим, как изменялась выручка по месяцам.

-- Наша задача — анализировать выручку по кварталам и категориям товаров.
SELECT 
    CONCAT(YEAR(Дата_Заказа), '-Q', QUARTER(Дата_Заказа)) AS Квартал, 
    Категория,
    SUM(Сумма_Продажи) AS Выручка
FROM my_table
GROUP BY Квартал, Категория
ORDER BY Квартал, Категория;
# Результат — видим, какие категории товаров приносят наибольшую прибыль в разные периоды.

-- Наша задача — определить регионы с наибольшей выручкой по годам.
SELECT 
    YEAR(Дата_Заказа) AS Год, 
    Регион, 
    SUM(Сумма_Продажи) AS Выручка
FROM my_table
GROUP BY Год, Регион
ORDER BY Год, Выручка DESC;
# Результат — выявляем регионы с самыми высокими продажами.

-- Наша задача — определить самую высокую и самую низкую выручку по штатам.
SELECT 
    Штат, 
    SUM(Сумма_Продажи) AS Выручка
FROM my_table
GROUP BY Штат
ORDER BY Выручка DESC;
# Результат — определяем наиболее прибыльные и наименее прибыльные штаты.

-- Наша задача — вычислить выручку по сегментам клиентов в разрезе лет.
SELECT 
    YEAR(Дата_Заказа) AS Год, 
    Сегмент, 
    SUM(Сумма_Продажи) AS Выручка
FROM my_table
GROUP BY Год, Сегмент
ORDER BY Год, Выручка DESC;
# Результат — определяем наиболее прибыльные клиентские сегменты.

-- Наша задача — определить 100 самых продаваемых товаров.
SELECT 
    Название_Товара, 
    SUM(Сумма_Продажи) AS Выручка
FROM my_table
GROUP BY Название_Товара
ORDER BY Выручка DESC
LIMIT 100;
# Результат — определяем товары, на которые стоит делать акцент.

-- Наша задача — определить 100 наименее продаваемых товаров.
SELECT 
    Название_Товара, 
    SUM(Сумма_Продажи) AS Выручка
FROM my_table
GROUP BY Название_Товара
HAVING Выручка > 0
ORDER BY Выручка ASC
LIMIT 100;
# Результат — выявляем товары с низкими продажами, которые могут нуждаться в скидках.

-- Наша задача — рассчитать средний чек.
SELECT 
    ROUND(AVG(Сумма_Заказа), 2) AS Средний_Чек
FROM (
    SELECT ID_Заказа, SUM(Сумма_Продажи) AS Сумма_Заказа
    FROM my_table
    GROUP BY ID_Заказа
) AS Подзапрос;
# Результат — узнаем, сколько в среднем тратит клиент за одну покупку.

-- Наша задача — определить долю клиентов, которые делают повторные покупки.
SELECT 
    COUNT(DISTINCT ID_Клиента) AS Всего_Клиентов,
    COUNT(DISTINCT CASE WHEN Количество_Заказов > 1 THEN ID_Клиента END) AS Повторные_Клиенты,
    ROUND((COUNT(DISTINCT CASE WHEN Количество_Заказов > 1 THEN ID_Клиента END) / COUNT(DISTINCT ID_Клиента)) * 100, 0) AS Доля_Повторных_Клиентов
FROM (
    SELECT ID_Клиента, COUNT(DISTINCT ID_Заказа) AS Количество_Заказов
    FROM my_table
    GROUP BY ID_Клиента
) AS Подзапрос;
# Результат — понимаем, сколько клиентов возвращается за повторными покупками.

-- Наша задача — рассчитать скользящее среднее для анализа трендов продаж.
SELECT 
    DATE_FORMAT(Дата_Заказа, '%Y-%m') AS Месяц,
    SUM(Сумма_Продажи) AS Выручка_За_Месяц,
    ROUND(AVG(SUM(Сумма_Продажи)) OVER (
        ORDER BY DATE_FORMAT(Дата_Заказа, '%Y-%m') 
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ), 2) AS Скользящее_Среднее_3Мес,
    ROUND(AVG(SUM(Сумма_Продажи)) OVER (
        ORDER BY DATE_FORMAT(Дата_Заказа, '%Y-%m') 
        ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ), 2) AS Скользящее_Среднее_6Мес
FROM my_table
GROUP BY Месяц
ORDER BY Месяц;
# Результат — видим сглаженный тренд продаж для анализа в BI.



